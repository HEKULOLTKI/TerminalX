在代码中显示消息为 `[object Object]` 通常是因为代码尝试将一个对象直接作为字符串显示，而 JavaScript 在这种情况下会默认调用对象的 `toString()` 方法，该方法对于普通对象会返回 `[object Object]`。下面我们来详细分析代码中可能导致此问题的地方。

### 可能的问题点及解决办法

#### 1. `addMessage` 函数中的内容转换
在 `addMessage` 函数里，虽然有对消息内容进行类型校验和转换的逻辑，但可能存在未覆盖到的情况。代码如下：
```javascript
// 添加消息
const addMessage = async (type, content, useTypewriter = false) => {
  console.log('添加消息:', type, content)
  
  // 强化类型校验和安全转换
  if (typeof content !== 'string') {
    console.error('Invalid message content type:', typeof content, content)
    
    // 更安全的类型转换逻辑
    if (content === null || content === undefined) {
      content = ''
    } else if (typeof content === 'object') {
      // 检查是否为数组
      if (Array.isArray(content)) {
        content = content.join('\n')
      } else {
        // 对象转换为格式化的JSON字符串
        try {
          content = JSON.stringify(content, null, 2)
        } catch (e) {
          content = '[对象转换失败]'
        }
      }
    } else {
      // 其他类型直接转换为字符串
      content = String(content)
    }
    
    // 记录转换日志
    console.warn('消息内容已转换为字符串:', content)
    showNotification('消息内容已自动转换为文本格式', 'warning')
  }
  
  // ... 其他代码 ...
}
```
**解决办法**：确保这个转换逻辑能正确处理所有传入的对象。若这个函数中的转换逻辑没问题，那就得检查调用 `addMessage` 函数时传入的 `content` 参数是否正确。

#### 2. 消息显示时的处理
在消息显示部分，可能存在直接显示对象而未进行正确转换的情况。例如，在模板中显示消息内容：
```vue
<div 
  v-if="message.type === 'ai' && message.useTypewriter" 
  class="message-bubble typewriter-bubble"
  @click="skipTypewriter(message)"
  :title="message.isTypingComplete ? '' : '点击跳过打字机效果'"
>
  <div 
    class="typewriter-formatted-content"
    v-html="ensureString(message.formattedDisplayText)"
    @click.stop="handleCodeCopy"
  ></div>
</div>
<div 
  v-else
  class="message-bubble" 
  v-html="ensureString(message.formattedContent)"
  @click.stop="handleCodeCopy"
></div>
```
这里的 `message.formattedDisplayText` 和 `message.formattedContent` 应该是字符串类型。若它们不小心被赋值为对象，就会显示 `[object Object]`。

**解决办法**：检查 `formatMessage` 函数（用于格式化消息内容）是否会意外返回对象：
```javascript
// 假设这是 formatMessage 函数的调用处
const formattedContent = await formatMessage(content)
```
确保 `formatMessage` 函数总是返回字符串：
```javascript
const formatMessage = async (text) => {
  // 确保 text 是字符串类型
  if (typeof text !== 'string') {
    text = String(text || '')
  }
  
  // 处理 Markdown 格式
  let formatted = marked(text)
  
  // 处理 Mermaid 图表
  formatted = await processMermaidDiagrams(formatted)
  
  return formatted
}
```

#### 3. 调试建议
- **日志输出**：在关键位置添加日志输出，检查变量的类型和值。例如，在 `addMessage` 函数和 `formatMessage` 函数中添加日志：
```javascript
const addMessage = async (type, content, useTypewriter = false) => {
  console.log('添加消息，content 类型:', typeof content, '值:', content)
  // ... 其他代码 ...
}

const formatMessage = async (text) => {
  console.log('格式化消息，text 类型:', typeof text, '值:', text)
  // ... 其他代码 ...
}
```
- **断点调试**：使用浏览器的开发者工具，在关键代码位置设置断点，逐步调试，查看变量的值和类型。

通过以上分析和调试方法，应该可以找出导致消息显示为 `[object Object]` 的具体原因。